package antlr;

/**
 * <b>SOFTWARE RIGHTS</b>
 * <p>
 * ANTLR 2.5.0 MageLang Institute, 1998
 * <p>
 * We reserve no legal rights to the ANTLR--it is fully in the
 * public domain. An individual or company may do whatever
 * they wish with source code distributed with ANTLR or the
 * code generated by ANTLR, including the incorporation of
 * ANTLR, or its output, into commerical software.
 * <p>
 * We encourage users to develop software with ANTLR. However,
 * we do ask that credit is given to us for developing
 * ANTLR. By "credit", we mean that if you use ANTLR or
 * incorporate any source code into one of your programs
 * (commercial product, research project, or otherwise) that
 * you acknowledge this fact somewhere in the documentation,
 * research report, etc... If you like ANTLR and have
 * developed a nice tool with the output, please mention that
 * you developed it using ANTLR. In addition, we ask that the
 * headers remain intact in our source code. As long as these
 * guidelines are kept, we expect to continue enhancing this
 * system and expect to make other tools available as they are
 * completed.
 * <p>
 * The ANTLR gang:
 * @version ANTLR 2.5.0 MageLang Institute, 1998
 * @author Terence Parr, <a href=http://www.MageLang.com>MageLang Institute</a>
 * @author <br>John Lilley, <a href=http://www.Empathy.com>Empathy Software</a>
 */
import java.util.Hashtable;
import antlr.collections.impl.BitSet;

/**DefineGrammarSymbols is a behavior for the ANTLRParser that adds all
 * the token and rule symbols to the grammar symbol table.
 *
 * Token types are assigned to token symbols in this class also.
 * The token type for a token is done in the order seen (lexically).
 */
public class DefineGrammarSymbols implements ANTLRGrammarParseBehavior {
	// Contains all of the defined parser and lexer Grammar's indexed by name
	protected Hashtable grammars = new Hashtable();
	// Contains all the TokenManagers indexed by name
	protected Hashtable tokenManagers = new Hashtable();
	// Current grammar (parser or lexer)
	protected Grammar grammar;
	// The tool under which this is invoked
	protected Tool tool;
	// The grammar analyzer object
	LLkAnalyzer analyzer;
	// The command-line arguments passed to the tool.
	// This allows each grammar to parse the arguments as it is created
	String[] args;
	// Name for default token manager does not match any valid name
	static final String DEFAULT_TOKENMANAGER_NAME = "*default";
	// Header action applies to all parsers unless redefined
	protected String headerAction = null;
	// Place where preamble is stored until a grammar is defined
	String thePreambleAction = null;
	// The target language
	String language = "Java";


	public DefineGrammarSymbols(Tool tool_, String[] args_, LLkAnalyzer analyzer_) {
		tool = tool_;
		args = args_;
		analyzer = analyzer_;
	}
	/** Abort the processing of a grammar due to syntax errors */
	public void abortGrammar() {
		if (grammar != null && grammar.getClassName() != null) {
			grammars.remove(grammar.getClassName());
		}
		grammar = null;
	}
	public void beginAlt(boolean doAST_) {
	}
	public void beginChildList() {
	}
	// Exception handling
	public void beginExceptionGroup() {}
	public void beginExceptionSpec(Token label) {}
	public void beginSubRule(Token label, int line, boolean not) {
	}
	public void beginTree(int line)  throws SemanticException {
	}
	/** Define a lexer or parser rule */
	public void defineRuleName(Token r, String access, boolean ruleAutoGen, String docComment) throws SemanticException {
		String id = r.getText();
		
		if ( Character.isUpperCase(id.charAt(0)) ) { 
			// lexer rule
			id = CodeGenerator.lexerRuleName(id);
			// make sure we define it as token identifier also
			if ( !grammar.tokenManager.tokenDefined(r.getText()) ) {
				int tt = grammar.tokenManager.nextTokenType();
				if (tt != 0) {
					TokenSymbol ts = new TokenSymbol(r.getText());
					ts.setTokenType(tt);
					grammar.tokenManager.define(ts);
				} else {
					tool.error("You cannot define new tokens when using tokdef", r.getLine());
				}
			}
		}

		RuleSymbol rs;
		if ( grammar.isDefined(id) ) {	// symbol seen before?
			rs = (RuleSymbol) grammar.getSymbol(id);
			// rule just referenced or has it been defined yet?
			if ( rs.isDefined() ) {
				tool.error("redefinition of rule "+id, r.getLine());
			}
		}
		else {
			rs = new RuleSymbol(id);
			grammar.define(rs);
		}
		rs.setDefined();
		rs.access = access;
		rs.comment = docComment;
	}
	public void endAlt() {
	}
	public void endChildList() {
	}
	public void endExceptionGroup() {}
	public void endExceptionSpec() {}
	public void endGrammar() {
	}
	/** Called after the optional options section, to compensate for
	 * options that may not have been set
	 */
	public void endOptions() {
		if (grammar.tokenManager == null) {
			if (tokenManagers.containsKey(DEFAULT_TOKENMANAGER_NAME)) {
				// Use the already-defined token manager
				TokenManager tm = (TokenManager)tokenManagers.get(DEFAULT_TOKENMANAGER_NAME);
				// tool.warning("No tokenVocabulary for '" + grammar.getClassName() + "', using '" + tm.getName() + "'");
				grammar.setTokenManager(tm);
			} else {
				// tool.warning("No tokenVocabulary for '" + grammar.getClassName() + "', using '" + grammar.getClassName() + "'");
				TokenManager tm = new SimpleTokenManager(grammar.getClassName(), tool);
				grammar.setTokenManager(tm);
				// Add the token manager to the list of token managers
				tokenManagers.put(DEFAULT_TOKENMANAGER_NAME, grammar.tokenManager);
			}
		}
	}
	public void endRule(String r) {
	}
	public void endSubRule() {
	}
	public void endTree() {
	}
	public void hasError() {
	}
	public void noASTSubRule() {
	}
	public void oneOrMoreSubRule() {
	}
	public void optionalSubRule() {
	}
	public void refAction(Token action) {
	}
	public void refArgAction(Token action) {
	}
	public void refCharLiteral(Token lit, Token label, boolean inverted, int autoGenType, boolean lastInRule) {
	}
	public void refCharRange(Token t1, Token t2, Token label, int autoGenType, boolean lastInRule) {
	}
	public void refExceptionHandler(Token exTypeAndName, String action) {}
	// Header action applies to all parsers and lexers.
	public void refHeaderAction(Token act) {
		headerAction = act.getText();
	}
	public void refInitAction(Token action) {
	}
	public void refMemberAction(Token act) {
	}
	public void refPreambleAction(Token act) {
		thePreambleAction = act.getText();
	}
	public void refReturnAction(Token returnAction) {
	}
	public void refRule(Token idAssign, Token r, Token label, Token args, int autoGenType) {
		String id = r.getText();
		if ( Character.isUpperCase(id.charAt(0)) ) { // lexer rule?
			id = CodeGenerator.lexerRuleName(id);
		}
		if ( !grammar.isDefined(id) ) {
			grammar.define(new RuleSymbol(id));
		}
	}
	public void refSemPred(Token pred) {
	}
	public void refStringLiteral(Token lit, Token label, int autoGenType, boolean lastInRule) {
		if (!(grammar instanceof LexerGrammar)) {
			// String literals are treated like tokens except by the lexer
			String str = lit.getText();
			if ( grammar.tokenManager.getTokenSymbol(str) != null ) {
				// string symbol is already defined
				return;
			}
			StringLiteralSymbol sl = new StringLiteralSymbol(str);
			int tt = grammar.tokenManager.nextTokenType();
			if (tt != 0) {
				sl.setTokenType(tt);
				grammar.tokenManager.define(sl);
			} else {
				tool.error("You cannot define new string literals when using tokdef", lit.getLine());
			}
		}
	}
	/** Reference a token */
	public void refToken(Token assignId, Token t, Token label, Token args,
		boolean inverted, int autoGenType, boolean lastInRule) {
		String id = t.getText();
		if ( !grammar.tokenManager.tokenDefined(id) ) {
			int tt = grammar.tokenManager.nextTokenType();
			if (tt != 0) {
				TokenSymbol ts = new TokenSymbol(id);
				ts.setTokenType(tt);
				grammar.tokenManager.define(ts);
			} else {
				tool.error("You cannot define new tokens when using tokdef", t.getLine());
			}
		}
	}
	public void refTokenRange(Token t1, Token t2, Token label, int autoGenType, boolean lastInRule) {
		if ( t1.getText().charAt(0) == '"' ) {
			refStringLiteral(t1, null, GrammarElement.AUTO_GEN_NONE, lastInRule);
		}
		else {
			refToken(null, t1, null, null, false, GrammarElement.AUTO_GEN_NONE, lastInRule);
		}
		if ( t2.getText().charAt(0) == '"' ) {
			refStringLiteral(t2, null, GrammarElement.AUTO_GEN_NONE, lastInRule);
		}
		else {
			refToken(null, t2, null, null, false, GrammarElement.AUTO_GEN_NONE, lastInRule);
		}
	}
	public void refTreeSpecifier(Token treeSpec) {}
	public void refWildcard(Token t, Token label, int autoGenType) {
	}
	/** Get ready to process a new grammar */
	public void reset() {
		grammar = null;
	}
	public void setArgOfRuleRef(Token argaction) {
	}
	/** Set the character vocabulary for a lexer */
	public void setCharVocabulary(BitSet b) {
		// grammar should enforce that this is only called for lexer
		((LexerGrammar)grammar).setCharVocabulary(b);
	}
	/** setFileOption: Associate an option value with a key.
	 * This applies to options for an entire grammar file.
	 * @param key The token containing the option name
	 * @param value The token containing the option value.
	 */
	public void setFileOption(Token key, Token value)
	{
		if (key.getText().equals("language")) {
			if (value.getType() == ANTLRParser.STRING_LITERAL) {
				language = Tool.stripBack(Tool.stripFront(value.getText(), '"'), '"');
			} 
			else if (value.getType() == ANTLRParser.TOKEN_REF || value.getType() == ANTLRParser.RULE_REF) {
				language = value.getText();
			} 
			else {
				tool.error("language option must be string or identifier", value.getLine());
			}
		}
		else if (key.getText().equals("mangleLiteralPrefix")) {
			if (value.getType() == ANTLRParser.STRING_LITERAL) {
				tool.literalsPrefix = tool.stripFrontBack(value.getText(), "\"","\"");
			}
			else {
				tool.error("mangleLiteralPrefix option must be string", value.getLine());
			}	
		}
		else if (key.getText().equals("upperCaseMangledLiterals")) {
			if (value.getText().equals("true")) {
				tool.upperCaseMangledLiterals = true;
			} else if (value.getText().equals("false")) {
				tool.upperCaseMangledLiterals = false;
			} else {
				grammar.tool.error("Value for upperCaseMangledLiterals must be true or false", key.getLine());
			}
		}
		else {
			tool.error("Invalid file-level option: " + key.getText(), key.getLine());
		}
	}
	/** setGrammarOption: Associate an option value with a key.
	 * This function forwards to Grammar.setOption for some options.
	 * @param key The token containing the option name
	 * @param value The token containing the option value.
	 */
	public void setGrammarOption(Token key, Token value)
	{
		if (key.getText().equals("tokenVocabulary")) {
			//System.out.println("Setting token vocabulary to '" + value.getText() + "'");
			// Set the token manager associated with the parser
			if (grammar.tokenManager != null) {
				tool.error("Only one tokdef or tokenVocabulary option may be specified", value.getLine());
			}
			else {
				// set the associated tokdef token manager 
				if (tokenManagers.containsKey(value.getText())) {
					// Use the already-defined token manager
					TokenManager tm = (TokenManager)tokenManagers.get(value.getText());
					if (tm instanceof SimpleTokenManager) {
						grammar.setTokenManager(tm);
					}
					else {
						tool.error("'" + value.getText() + "' is already defined as something else", value.getLine());
					}
				}
				else {
					if (value.getType() == ANTLRParser.RULE_REF || value.getType() == ANTLRParser.TOKEN_REF) {
						// Create a simple token manager
						SimpleTokenManager tm = new SimpleTokenManager(value.getText(), tool);
						// Add this token manager to the list so its tokens will be generated
						tokenManagers.put(tm.getName(), tm);
						// Assign the token manager to this grammar.
						grammar.setTokenManager(tm);
					}
					else {
						tool.error("tokenVocabulary must be an identifier", value.getLine());
					}
				}
			}
		}
		else if (key.getText().equals("tokdef")) {
			// Set the token manager associated with the parser
			if (grammar instanceof LexerGrammar) {
				tool.error("tokdef= option cannot be used with a lexer", key.getLine());
			}
			else if (grammar.tokenManager != null) {
				tool.error("Only one tokdef or tokenVocabulary option may be specified", value.getLine());
			}
			else {
				// set the associated tokdef token manager 
				if (tokenManagers.containsKey(value.getText())) {
					// Use the already-defined tokdef manager
					TokenManager tm = (TokenManager)tokenManagers.get(value.getText());
					if (tm instanceof TokdefTokenManager) {
						grammar.setTokenManager(tm);
					}
					else {
						tool.error("'" + value.getText() + "' is already defined as something else", value.getLine());
					}
				}
				else {
					if (value.getType() == ANTLRParser.STRING_LITERAL) {
						// Create a new tokdef manager
						String filename = value.getText();
						// Strip ""
						filename = filename.substring(1, filename.length()-1);
						// Create a tokdef token manager from the given file
						TokdefTokenManager tm = new TokdefTokenManager(grammar, filename, tool);
						// Add this token manager to the list so its tokens will be generated
						tokenManagers.put(tm.getName(), tm);
						// Assign the token manager to this grammar.
						grammar.setTokenManager(tm);
					}
					else {
						tool.error("tokdef filename must be double-quoted", value.getLine());
					}
				}
			}
		}

		else {
			// Forward all unrecognized options to the grammar
			grammar.setOption(key.getText(), value);
		}
	}
	public void setRuleOption(Token key, Token value) {
	}
	public void setSubruleOption(Token key, Token value) {
	}
	/** Start a new lexer */
	public void startLexer(Token name, String superClass, String doc)
	{
		reset();
		//System.out.println("Processing lexer '" + name.getText() + "'");
		// Does the lexer already exist?
		Grammar g = (Grammar)grammars.get(name);
		if (g != null) {
			if (!(g instanceof LexerGrammar)) {
				tool.panic("'" + name.getText() + "' is already defined as a non-lexer");
			} else {
				tool.panic("Lexer '" + name.getText() + "' is already defined");
			}
		}
		else {
			// Create a new lexer grammar
			LexerGrammar lg = new LexerGrammar(name.getText(), tool, superClass);
			lg.comment = doc;
			lg.processArguments(args);
			grammars.put(lg.getClassName(), lg);
			// Use any preamble action
			lg.preambleAction = thePreambleAction;
			thePreambleAction = null;
			// This is now the current grammar
			grammar = lg;
		}
	}
	/** Start a new parser */
	public void startParser(Token name, String superClass, String doc)
	{
		reset();
		//System.out.println("Processing parser '" + name.getText() + "'");
		// Is this grammar already defined?
		Grammar g = (Grammar)grammars.get(name);
		if (g != null) {
			if (!(g instanceof ParserGrammar)) {
				tool.panic("'" + name.getText() + "' is already defined as a non-parser");
			} else {
				tool.panic("Parser '" + name.getText() + "' is already defined");
			}
		}
		else {
			// Create a new grammar
			grammar = new ParserGrammar(name.getText(), tool, superClass);
			grammar.comment = doc;
			grammar.processArguments(args);
			grammars.put(grammar.getClassName(), grammar);
			// Use any preamble action
			grammar.preambleAction = thePreambleAction;
			thePreambleAction = null;
		}
	}
	/** Start a new tree-walker */
	public void startTreeWalker(Token name, String superClass, String doc)
	{
		reset();
		//System.out.println("Processing tree-walker '" + name.getText() + "'");
		// Is this grammar already defined?
		Grammar g = (Grammar)grammars.get(name);
		if (g != null) {
			if (!(g instanceof TreeWalkerGrammar)) {
				tool.panic("'" + name.getText() + "' is already defined as a non-tree-walker");
			} else {
				tool.panic("Tree-walker '" + name.getText() + "' is already defined");
			}
		}
		else {
			// Create a new grammar
			grammar = new TreeWalkerGrammar(name.getText(), tool, superClass);
			grammar.comment = doc;
			grammar.processArguments(args);
			grammars.put(grammar.getClassName(), grammar);
			// Use any preamble action
			grammar.preambleAction = thePreambleAction;
			thePreambleAction = null;
		}
	}
	public void synPred() {
	}
	public void zeroOrMoreSubRule() {
	}
}
