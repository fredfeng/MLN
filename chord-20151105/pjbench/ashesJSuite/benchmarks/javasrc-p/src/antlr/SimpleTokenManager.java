package antlr;

/**
 * <b>SOFTWARE RIGHTS</b>
 * <p>
 * ANTLR 2.5.0 MageLang Institute, 1998
 * <p>
 * We reserve no legal rights to the ANTLR--it is fully in the
 * public domain. An individual or company may do whatever
 * they wish with source code distributed with ANTLR or the
 * code generated by ANTLR, including the incorporation of
 * ANTLR, or its output, into commerical software.
 * <p>
 * We encourage users to develop software with ANTLR. However,
 * we do ask that credit is given to us for developing
 * ANTLR. By "credit", we mean that if you use ANTLR or
 * incorporate any source code into one of your programs
 * (commercial product, research project, or otherwise) that
 * you acknowledge this fact somewhere in the documentation,
 * research report, etc... If you like ANTLR and have
 * developed a nice tool with the output, please mention that
 * you developed it using ANTLR. In addition, we ask that the
 * headers remain intact in our source code. As long as these
 * guidelines are kept, we expect to continue enhancing this
 * system and expect to make other tools available as they are
 * completed.
 * <p>
 * The ANTLR gang:
 * @version ANTLR 2.5.0 MageLang Institute, 1998
 * @author Terence Parr, <a href=http://www.MageLang.com>MageLang Institute</a>
 * @author <br>John Lilley, <a href=http://www.Empathy.com>Empathy Software</a>
 */
import java.io.*;
import java.util.Hashtable;
import java.util.Enumeration;
import antlr.collections.impl.Vector;

class SimpleTokenManager implements TokenManager {
	protected int maxToken = Token.MIN_USER_TYPE;
	// Token vocabulary is Vector of String's
	protected Vector vocabulary;
	// Hash table is a mapping from Strings to TokenSymbol
	private Hashtable table;
	// the ANTLR tool
	protected Tool tool;
	// Name of the token manager
	protected String name;


	SimpleTokenManager(String name_, Tool tool_) {
		tool = tool_;
		name = name_;
		// Don't make a bigger vector than we need, because it will show up in output sets.
		vocabulary = new Vector(1);
		table = new Hashtable();

		// define EOF symbol
		TokenSymbol ts = new TokenSymbol("EOF");
		ts.setTokenType(Token.EOF_TYPE);
		define(ts);

/*
		// define <epsilon> but only in the vocabulary vector
		vocabulary.ensureCapacity(GrammarAnalyzer.EPSILON_TYPE);
		// The only time epsilon can appear (in warning) is when
		// it implies end-of-syn-pred, so we just set its string here.
		vocabulary.setElementAt("<end-of-syn-pred>", GrammarAnalyzer.EPSILON_TYPE);
*/

		// define <null-tree-lookahead> but only in the vocabulary vector
		vocabulary.ensureCapacity(Token.NULL_TREE_LOOKAHEAD);
		vocabulary.setElementAt("NULL_TREE_LOOKAHEAD", Token.NULL_TREE_LOOKAHEAD);
	}
	/** define a token */
	public void define(TokenSymbol ts) {
		// Add the symbol to the vocabulary vector
		vocabulary.ensureCapacity(ts.getTokenType());
		vocabulary.setElementAt(ts.getId(), ts.getTokenType());
		// add the symbol to the hash table
		table.put(ts.getId(), ts);
	}
	/** Simple token manager doesn't have a name -- must be set externally */
	public String getName() { return name; }
	/** Get a token symbol by index */
	public String getTokenStringAt(int idx) {
		return (String)vocabulary.elementAt(idx);
	}
	/** Get the TokenSymbol for a string */
	public TokenSymbol getTokenSymbol(String sym) {
		return (TokenSymbol)table.get(sym);
	}
	/** Get an enumerator over the symbol table */
	public Enumeration getTokenSymbolElements() {
		return table.elements();
	}
	/** Get the token vocabulary (read-only).
	 * @return A Vector of TokenSymbol 
	 */
	public Vector getVocabulary() {
		return vocabulary;
	}
	/** Simple token manager is not read-only */
	public boolean isReadOnly() { return false; }
	/** Get the highest token type in use */
	public int maxTokenType() {
		return maxToken-1;
	}
	/** Get the next unused token type */
	public int nextTokenType() {
		return maxToken++;
	}
	/** Set the name of the token manager */
	public void setName(String name_) { name = name_; }
	/** Is a token symbol defined? */
	public boolean tokenDefined(String symbol) {
		return table.containsKey(symbol);
	}
}
