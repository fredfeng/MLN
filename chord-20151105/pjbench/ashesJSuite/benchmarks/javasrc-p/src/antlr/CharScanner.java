package antlr;

/**
 * <b>SOFTWARE RIGHTS</b>
 * <p>
 * ANTLR 2.5.0 MageLang Institute, 1998
 * <p>
 * We reserve no legal rights to the ANTLR--it is fully in the
 * public domain. An individual or company may do whatever
 * they wish with source code distributed with ANTLR or the
 * code generated by ANTLR, including the incorporation of
 * ANTLR, or its output, into commerical software.
 * <p>
 * We encourage users to develop software with ANTLR. However,
 * we do ask that credit is given to us for developing
 * ANTLR. By "credit", we mean that if you use ANTLR or
 * incorporate any source code into one of your programs
 * (commercial product, research project, or otherwise) that
 * you acknowledge this fact somewhere in the documentation,
 * research report, etc... If you like ANTLR and have
 * developed a nice tool with the output, please mention that
 * you developed it using ANTLR. In addition, we ask that the
 * headers remain intact in our source code. As long as these
 * guidelines are kept, we expect to continue enhancing this
 * system and expect to make other tools available as they are
 * completed.
 * <p>
 * The ANTLR gang:
 * @version ANTLR 2.5.0 MageLang Institute, 1998
 * @author Terence Parr, <a href=http://www.MageLang.com>MageLang Institute</a>
 * @author <br>John Lilley, <a href=http://www.Empathy.com>Empathy Software</a>
 */
import java.util.Hashtable;
import antlr.collections.impl.BitSet;
import java.io.IOException;

public abstract class CharScanner implements Tokenizer {
	static final char NO_CHAR = 0;
	public static final char EOF_CHAR = (char)-1;
	protected int line = 1;						// current line number
	protected ANTLRStringBuffer text;			// text of current token
	protected boolean saveConsumedInput = true;	// does consume() save characters?
	protected Class tokenObjectClass;			// what kind of tokens to create?
	protected int guessing = 0;
	protected boolean caseSensitive = true;
	protected boolean caseSensitiveLiterals = true;
	protected Hashtable literals;				// set by subclass
	
	protected Token _returnToken = null;		// used to return tokens w/o using return val.

	// Hash string used so we don't new one every time to check literals table
	protected ANTLRHashString hashString;

	// Input chars
	InputBuffer input;

	/** Used during filter mode to indicate that path is desired.
	 *  A subsequent scan error will report an error as usual if acceptPath=true;
	 */
	protected boolean commitToPath = false;

public CharScanner(InputBuffer cb) { // SAS: use generic buffer
	text = new ANTLRStringBuffer();
	hashString = new ANTLRHashString(this);
	setTokenObjectClass("antlr.CommonToken");
	input = cb;
}
public void append(char c) {
	if ( saveConsumedInput ) {
		text.append(c);
	}	
}
public void append(String s) {
	if ( saveConsumedInput ) {
		text.append(s);
	}	
}
	public void commit() {
		input.commit();
	}
public void consume() throws IOException {
	if (guessing == 0) {
		if (caseSensitive) {
			append(LA(1));
		} else {
			// use input.LA(), not LA(), to get original case
			// CharScanner.LA() would toLower it.
			append(input.LA(1));
		}
	}
	input.consume();
}
	/** Consume chars until one matches the given char */
	public void consumeUntil(int c) throws IOException {
		while (LA(1) != EOF_CHAR && LA(1) != c)
		{
			consume();
		}
	}
	/** Consume chars until one matches the given set */
	public void consumeUntil(BitSet set) throws IOException {
		while (LA(1) != EOF_CHAR && !set.member(LA(1))) {
			consume();
		}
	}
	public boolean getCaseSensitive() { return caseSensitive; }
	public final boolean getCaseSensitiveLiterals() { return caseSensitiveLiterals; }
	public boolean getCommitToPath() { return commitToPath; }
	public InputBuffer getInputBuffer() {
		return input;
	}
	public int getLine() { return line; }
	// return a copy of the current text buffer
	public String getText() {
		return text.toString();
	}
	public Token getTokenObject() {
		return _returnToken;
	}
public char LA(int i) throws IOException {
	if (caseSensitive) {
		return input.LA(i);
	} else {
		return toLower(input.LA(i));
	}
}
	protected Token makeToken(int t) {
		try {
			Token tok = (Token)tokenObjectClass.newInstance();
			tok.setType(t);
			// tok.setText(getText()); done in generated lexer now
			tok.setLine(line);
			return tok;
		}
		catch (InstantiationException ie) {
			panic("can't instantiate a Token");
		}
		catch (IllegalAccessException iae) {
			panic("Token class is not accessible");
		}
		return Token.badToken;
	}
	public int mark() {
		return input.mark();
	}
	public void match(char c) throws ScannerException, IOException {
		if ( LA(1) != c ) {
			throw new ScannerException("mismatched char: '" + LA(1) + "' expected '"+c+"'", line);
		}
		consume();
	}
	public void match(BitSet b) throws ScannerException, IOException {
		if ( !b.member(LA(1)) ) {
			throw new ScannerException("mismatched char: '" + LA(1) + "'", line);
		} else {
			consume();
		}
	}
	public void match(String s) throws ScannerException, IOException {
		int len = s.length();
		for (int i=0; i<len; i++) {
			if ( LA(1) != s.charAt(i) ) {
				throw new ScannerException("mismatched char: '" + LA(1) + "'", line);
			}
			consume();
		}
	}
	public void matchNot(char c) throws ScannerException, IOException {
		if ( LA(1) == c ) {
			throw new ScannerException("mismatched char: '"+ LA(1) + "'", line);
		}
		consume();
	}
	public void matchRange(char c1, char c2) throws ScannerException, IOException {
		if ( LA(1) < c1 || LA(1) > c2 ) throw new ScannerException("char out of range: '" + LA(1) + "'", line);
		consume();
	}
	public void newline() { line++; }
	public void panic() {
		System.err.println("CharScanner: panic");
		System.exit(1);
	}
	public void panic(String s) {
		System.err.println("CharScanner; panic: "+s);
		System.exit(1);
	}
	/** Report exception errors caught in nextToken() */
	public void reportError(ScannerException e) {
		System.err.println("Scanner exception: " + e);
	}
	/** Parser error-reporting function can be overridden in subclass */
	public void reportError(String s) {
		System.err.println("Error: " + s);
	}
	/** Parser warning-reporting function can be overridden in subclass */
	public void reportWarning(String s) {
		System.out.println("Warning: " + s);
	}
	public void resetText() {
		text.setLength(0);
	}
	public void rewind(int pos) {
		input.rewind(pos);
	}
	public void setCaseSensitive(boolean t) { caseSensitive = t; }
	public void setCommitToPath(boolean commit) { commitToPath = commit; }
	public void setLine(int line) { this.line = line; }
	public void setText(String s) {
		resetText();
		text.append(s);
	}
	public void setTokenObjectClass(String cl) {
		try {
			tokenObjectClass = Class.forName(cl);
		}
		catch (ClassNotFoundException ce) {
			panic("ClassNotFoundException: "+cl);
		}
	}
	// Test the token text against the literals table
	// Override this method to perform a different literals test
	public int testLiteralsTable(int ttype) {
		hashString.setBuffer(text.getBuffer(), text.length());
		Integer literalsIndex = (Integer)literals.get(hashString);
		if (literalsIndex != null) {
			ttype = literalsIndex.intValue();
		}
		return ttype;
	}
	// Override this method to get more specific case handling
	public char toLower(char c) {
		return Character.toLowerCase(c);
	}
	public void traceIn(String rname) throws IOException {
		System.out.println("enter lexer "+rname+"; c==" + LA(1));
	}
	public void traceOut(String rname) throws IOException {
		System.out.println("exit lexer "+rname+"; c=='" + LA(1));
	}
}
